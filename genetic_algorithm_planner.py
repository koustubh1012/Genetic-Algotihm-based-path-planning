# -*- coding: utf-8 -*-
"""genetic_algorithm_planner.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fbP6jzoVzDDBk3rVgMnFr-cAboQYRh4v
"""

import matplotlib.pyplot as plt
import numpy as np
import random
import math
import cv2

size = (30, 50)
# obstacles = [(5, 5, 10,10), (20, 30, 25, 45), (15, 0, 20, 5), (15, 17, 20, 22)]
obstacles = [(5, 5, 10, 15), (20, 5, 25, 15), (5, 30, 10, 40), (20, 30, 25, 40), (3, 20, 12, 25), (18, 20, 27, 25)]
start = (0, 0)
plot_num = 0
# goal = (29, 40)
goal = (29, 35)
INITIAL_POPULATION_SIZE = 20
NUMBER_OF_GENERATIONS = 50
STEP_SIZE = 3
FPS = 2
generation_best_fitness = []

class Node:
  def __init__(self, x, y):
    self.x = x
    self.y = y
    self.parent_node = None


def is_within_obstacles(point, obstacles):
  for (x1, y1, x2, y2) in obstacles:
    if x1<=point[0]<=x2 and y1<=point[1]<=y2:
      return True
  return False


def distance(point1, point2):
  return np.sqrt((point1[0]-point2[0])**2 + (point1[1]-point2[1])**2)


def nearest_node(nodes, random_point):
  return min(nodes, key=lambda node: distance((node.x, node.y), random_point))


def steer(from_node, to_point, step_size=1):
  if distance((from_node.x, from_node.y), to_point)<step_size:
    return Node(to_point[0], to_point[1])
  else:
    theta = np.arctan2(to_point[1]-from_node.y, to_point[0]-from_node.x)
    return Node(from_node.x + step_size*np.cos(theta), from_node.y + step_size*np.sin(theta))


""" Check if the path between node1 and node2 is valid by interpolating points along the way. """
def is_valid_path(node1, node2, obstacles):
  steps = int(distance((node1.x, node1.y), (node2.x, node2.y))/0.5)  # Smaller steps for more accuracy

  for i in range(1, steps + 1):
    inter_x = node1.x + i*(node2.x-node1.x)/steps
    inter_y = node1.y + i*(node2.y-node1.y)/steps

    if is_within_obstacles((inter_x, inter_y), obstacles):
      return False
  return True


def plot(nodes=None, path=None):
    global plot_num
    fig, ax = plt.subplots()
    if nodes:
      for node in nodes:
          if node.parent_node:
              plt.plot([node.x, node.parent_node.x], [node.y, node.parent_node.y], "g-", linewidth=0.5)
    for (ox, oy, ex, ey) in obstacles:
        ax.add_patch(plt.Rectangle((ox, oy), ex-ox, ey-oy, color="red"))
    if path:
        plt.plot([node.x for node in path], [node.y for node in path], "b-", linewidth=2)  # Highlight path in blue
    plt.plot(start[0], start[1], "bo")  # Start
    plt.plot(goal[0], goal[1], "ro")  # Goal
    plt.grid(True)
    plt.savefig(f'plot_{plot_num + 1}.png')  # Save plot as PNG
    # plt.show()
    plot_num += 1


def rrt(step_size=1, max_nodes=10000):
    nodes = [Node(start[0], start[1])]
    while len(nodes) < max_nodes:
        random_point = (random.randint(0, size[0] - 1), random.randint(0, size[1] - 1))
        if is_within_obstacles(random_point, obstacles):
            continue
        nearest = nearest_node(nodes, random_point)
        new_node = steer(nearest, random_point, step_size)
        if not is_within_obstacles((new_node.x, new_node.y), obstacles) and is_valid_path(nearest, new_node, obstacles):
            new_node.parent_node = nearest
            nodes.append(new_node)
            if distance((new_node.x, new_node.y), goal) <= 2:#step_size:
                return nodes, new_node
    return nodes, None  # Return None if max_nodes reached without finding a path


def fitness_function(path):
    coordinates = [(node.x, node.y) for node in path]
    w1 = 3
    w2 = 1
    euc_dist = 0
    angle_sum = 0
    for i in range(len(coordinates)-1):
        x1, y1 = coordinates[i]
        x2, y2 = coordinates[i+1]
        dist_ = math.sqrt((x2-x1)**2 +(y2-y1)**2)
        euc_dist += dist_
        if i != len(coordinates)-2:
          x3, y3 = coordinates[i+2]
          heading1 = math.degrees(math.atan2((y2-y1),(x2-x1)))
          heading2 = math.degrees(math.atan2((y3-y2),(x3-x2)))
          if heading1 < 0:
            heading1 = 360 + heading1
          if heading2 < 0:
            heading2 = 360 + heading2
          angle = abs(heading2-heading1)
          angle_sum += angle

    F = w1*(1/(euc_dist))+ w2*1/(angle_sum)
    return euc_dist, F


def calculate_fitness_of_population(population):
  fitness = []
  for index, path in enumerate(population):
    euc_dist, F = fitness_function(path)
    fitness.append(F)
  return fitness


def selection(fitness, population):
  P1 = []
  P2 = []
  while(fitness):
    max_fitness = max(fitness)
    index = fitness.index(max_fitness)
    fitness.pop(index)
    P1.append(population.pop(index))

    l = len(fitness)
    i = random.randint(0, l-1)
    fitness.pop(i)
    P2.append(population.pop(i))
  return P1, P2


def best_selection(fitness, population):
  P1 = []
  P2 = []
  while(fitness):
    max_fitness = max(fitness)
    index = fitness.index(max_fitness)
    fitness.pop(index)
    P1.append(population.pop(index))

    max_fitness = max(fitness)
    index = fitness.index(max_fitness)
    fitness.pop(index)
    P2.append(population.pop(index))
  return P1, P2


def plot_best_solution(fitness, population, plot_graph=False):
  max_fitness = max(fitness)
  index = fitness.index(max_fitness)
  best_path = population[index]
  print(f"Fitness: {max_fitness}")
  if plot_graph:
    plot(path=best_path)
  return max_fitness


#CrossOver points
def crossoverpt(parent1,parent2):
    minval=2
    offspring1=[]
    offspring2=[]
    #range defined in such a way that it ignores inital and final points
    for pt1 in range(3, len(parent1)-3):
        for pt2 in range(3, len(parent2)-3):
            #Calculating  distance between every nodes of 2 paths and selecting the min distance path points
            if (math.sqrt((parent1[pt1].x-parent2[pt2].x)**2+(parent1[pt1].y-parent2[pt2].y)**2))<minval:
                # print("DISTANCE: ")
                # print(math.sqrt((parent1[pt1].x-parent2[pt2].x)**2+(parent1[pt1].y-parent2[pt2].y)**2))
                # print("parent1 point: ", parent1[pt1].x, parent1[pt1].y)
                # print("parent2 point: " , parent2[pt2].x, parent2[pt2].y)
                # if (minval>math.sqrt((parent1[1][pt1].x-parent2[1][pt2].x)**2+(parent1[1][pt1].y-parent2[1][pt2].y)**2)):
                minval=math.sqrt((parent1[pt1].x-parent2[pt2].x)**2+(parent1[pt1].y-parent2[pt2].y)**2)
                #storing path points indexes so to use them to crossover
                parent1_point_idx=pt1
                parent2_point_idx=pt2

    # Pruning the path and making crossover based on the indexes calculated
    for i in range(parent1_point_idx+1):
        offspring1.append(Node(parent1[i].x,parent1[i].y))
    for i in range(parent2_point_idx,len(parent2)):
        offspring1.append(Node(parent2[i].x,parent2[i].y))

    for i in range(parent2_point_idx+1):
        offspring2.append(Node(parent2[i].x,parent2[i].y))
    for i in range(parent1_point_idx,len(parent1)):
        offspring2.append(Node(parent1[i].x,parent1[i].y))


    #Returning offsprings
    return offspring1,offspring2


def elimination(fitness, population):
  num_eliminations = 2
  for i in range(0, num_eliminations):
    min_fitness = min(fitness)
    index = fitness.index(min_fitness)
    fitness.pop(index)
    population.pop(index)
  return fitness, population


def create_initial_population(population_size=20, step_size=1, plot_paths = True):
  population = []
  for i in range(population_size):
    nodes, final_node = rrt(step_size=step_size)
    path = []
    if final_node:
        while final_node.parent_node:
            path.append(final_node)
            final_node = final_node.parent_node
        path.append(final_node)
        path.reverse()
    if plot_paths:
      plot(nodes, path)
    population.append(path)
  return population


def create_opencv_visualisation(parent_gen_size=INITIAL_POPULATION_SIZE, generation_gen_size=100):
  fourcc = cv2.VideoWriter_fourcc(*'mp4v')
  video = cv2.VideoWriter("genetic.mp4", fourcc, FPS, (640, 480))
  for i in range(0, parent_gen_size+generation_gen_size):
    image = cv2.imread(f'plot_{i+1}.png')
    if i < parent_gen_size:
      fitness = parent_gen_fitness[i]
      cv2.putText(image, f"Parent: {i+1} | Fitness: {fitness}",(10,40),cv2.FONT_HERSHEY_SIMPLEX,0.8, (0,0,0), 1, cv2.LINE_AA)
    else:
      fitness = generation_best_fitness[i-parent_gen_size]
      cv2.putText(image, f"Generation: {i-parent_gen_size+1} | Fitness: {fitness}",(10,40),cv2.FONT_HERSHEY_SIMPLEX,0.8, (0,0,0), 1, cv2.LINE_AA)
    video.write(image)
  for i in range(20):
    video.write(image)

population = create_initial_population(population_size=INITIAL_POPULATION_SIZE, step_size=STEP_SIZE, plot_paths=True)
parent_gen_fitness = calculate_fitness_of_population(population)

for gen in range (0,NUMBER_OF_GENERATIONS):
  print(f"Generation: {gen+1}")
  if population:
    fitness = calculate_fitness_of_population(population)
    # fitness, population = elimination(fitness, population)
    best_fitness = plot_best_solution(fitness=fitness, population=population, plot_graph=True)
    generation_best_fitness.append(best_fitness)
    P1, P2 = best_selection(fitness, population)
    # P1, P2 = selection(fitness, population)
    # best_p1 = P1[0]
    # best_p2 = P2[0]
    # population.append(best_p1)
    # population.append(best_p2)
    for i in range(0,len(P1)):
      try:
        offspring1 , offspring2 = crossoverpt(P1[i], P2[i])
        population.append(offspring1)
        population.append(offspring2)
      except:
        pass
  else:
    NUMBER_OF_GENERATIONS = gen
    print(f"Termination at generation: {gen+1}")

create_opencv_visualisation(parent_gen_size=INITIAL_POPULATION_SIZE, generation_gen_size=NUMBER_OF_GENERATIONS)
